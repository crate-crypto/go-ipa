package common_test

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"testing"

	"github.com/crate-crypto/go-ipa/bandersnatch/fr"
	"github.com/crate-crypto/go-ipa/banderwagon"
	"github.com/crate-crypto/go-ipa/common"
	"github.com/crate-crypto/go-ipa/ipa"
)

func TestJavaRegressionOneEndian(t *testing.T) {
	hexStr := "f6e31f7a565a390b48fdd24569ac10d43562d19de37ea951c7f9f250a339d059"
	byteArray := hexStrToBytes(hexStr)
	_scalar, err := common.ReadScalar(bytes.NewReader(byteArray))

	if err == nil {
		t.Fatalf("expected an error because the scalar is too large")
	}
	_ = _scalar
}
func TestJavaRegressionOtherEndian(t *testing.T) {
	hexStr := "f6e31f7a565a390b48fdd24569ac10d43562d19de37ea951c7f9f250a339d059"
	byteArray := hexStrToBytes(hexStr)
	reverse(byteArray)
	_scalar, err := common.ReadScalar(bytes.NewReader(byteArray))
	if err == nil {
		t.Fatalf("expected an error because the scalar is too large, even though we changed the endian")
	}
	_ = _scalar
}

type AutoGenerated []struct {
	Frs      []string `json:"frs"`
	Expected string   `json:"expected"`
}

// genesis_lvl1_commitments.json was generated by serializing the scalars -1, -2,...,-256
// The scalars are encoded in big-endian format for now, so that the java code does not need
// much change.
func TestNewGenesisLvl1Commit(t *testing.T) {
	// Open the JSON file
	jsonFile, err := os.Open("../genesis_lvl1_commits.json")
	if err != nil {
		t.Fail()
		fmt.Println(err)
	}
	defer jsonFile.Close()

	// Read the opened jsonFile as a byte array.
	byteArray, _ := io.ReadAll(jsonFile)

	// We initialize our struct
	var testData AutoGenerated
	json.Unmarshal(byteArray, &testData)

	ipaConf, err := ipa.NewIPASettings()
	if err != nil {
		t.Fatalf("creating IPA settings: %s", err)
	}

	scalars := make([]fr.Element, common.VectorLength)

	serializedScalars := testData[0].Frs
	for i := 0; i < common.VectorLength; i++ {
		scalarBytes, err := hex.DecodeString(serializedScalars[i])
		if err != nil {
			t.Fatalf("decoding scalar bytes: %s", err)
		}
		reverse(scalarBytes) // Reverse bytes so we use LE
		scalars_i, err := common.ReadScalar(bytes.NewReader(scalarBytes))
		if err != nil {
			t.Fatalf("reading scalar: %s", err)
		}
		scalars[i] = *scalars_i
	}
	comm := ipaConf.Commit(scalars)
	commBytes := comm.Bytes()
	commHexStr := hex.EncodeToString(commBytes[:])
	if commHexStr != testData[0].Expected {
		t.Fatalf("expected %s, got %s", testData[0].Expected, commHexStr)
	}
}

func reverse(data []byte) {
	for i, j := 0, len(data)-1; i < j; i, j = i+1, j-1 {
		data[i], data[j] = data[j], data[i]
	}
}

func hexStrToBytes(numStr string) []byte {

	byteArray, err := hex.DecodeString(numStr)
	if err != nil {
		panic(err)
	}
	return byteArray
}

func GetTreeKeyWithEvaluatedAddress(evaluated *banderwagon.Element, index [32]byte, subIndex byte) []byte {
	var poly [5]fr.Element

	poly[0].SetZero()
	poly[1].SetZero()
	poly[2].SetZero()

	FromLEBytes(&poly[3], index[:16])
	FromLEBytes(&poly[4], index[16:])

	ipaConf, _ := ipa.NewIPASettings()
	ret := ipaConf.Commit(poly[:])

	// add the pre-evaluated address
	ret.Add(&ret, evaluated)

	return pointToHash(&ret, subIndex)
}

func GetTreeKey(address []byte, trieIndexBytes [32]byte, subIndex byte) []byte {
	var index0Point banderwagon.Element
	index0Point.SetBytes([]byte{34, 25, 109, 242, 193, 5, 144, 224, 76, 52, 189, 92, 197, 126, 9, 145, 27, 152, 199, 130, 165, 3, 210, 27, 193, 131, 142, 28, 110, 26, 16, 191})

	if len(address) < 32 {
		var aligned [32]byte
		address = append(aligned[:32-len(address)], address...)
	}
	// poly = [2+256*64, address_le_low, address_le_high, tree_index_le_low, tree_index_le_high]
	var poly [5]fr.Element

	// 32-byte address, interpreted as two little endian
	// 16-byte numbers.
	FromLEBytes(&poly[1], address[:16])
	FromLEBytes(&poly[2], address[16:])

	// treeIndex must be interpreted as a 32-byte aligned little-endian integer.
	// e.g: if treeIndex is 0xAABBCC, we need the byte representation to be 0xCCBBAA00...00.
	// poly[3] = LE({CC,BB,AA,00...0}) (16 bytes), poly[4]=LE({00,00,...}) (16 bytes).
	//
	// To avoid unnecessary endianness conversions for go-ipa, we do some trick:
	// - poly[3]'s byte representation is the same as the *top* 16 bytes (trieIndexBytes[16:]) of
	//   32-byte aligned big-endian representation (BE({00,...,AA,BB,CC})).
	// - poly[4]'s byte representation is the same as the *low* 16 bytes (trieIndexBytes[:16]) of
	//   the 32-byte aligned big-endian representation (BE({00,00,...}).
	FromBytes(&poly[3], trieIndexBytes[16:])
	FromBytes(&poly[4], trieIndexBytes[:16])

	ipaConf, _ := ipa.NewIPASettings()
	ret := ipaConf.Commit(poly[:])

	// add a constant point corresponding to poly[0]=[2+256*64].
	ret.Add(&ret, &index0Point)

	return pointToHash(&ret, subIndex)
}

func FromLEBytes(fr *banderwagon.Fr, data []byte) error {
	if len(data) > 32 {
		return errors.New("data is too long")
	}
	var aligned [32]byte
	copy(aligned[:], data)
	fr.SetBytesLE(aligned[:])
	return nil
}

func FromBytes(fr *banderwagon.Fr, data []byte) {
	var aligned [32]byte
	copy(aligned[32-len(data):], data)
	fr.SetBytes(aligned[:])
}

func pointToHash(evaluated *banderwagon.Element, suffix byte) []byte {
	// The output of Byte() is big endian for banderwagon. This
	// introduces an imbalance in the tree, because hashes are
	// elements of a 253-bit field. This means more than half the
	// tree would be empty. To avoid this problem, use a little
	// endian commitment and chop the MSB.
	bytes := evaluated.Bytes()
	for i := 0; i < 16; i++ {
		bytes[31-i], bytes[i] = bytes[i], bytes[31-i]
	}
	bytes[31] = suffix
	return bytes[:]
}
