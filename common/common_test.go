package common_test

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"testing"

	"github.com/crate-crypto/go-ipa/bandersnatch/fr"
	"github.com/crate-crypto/go-ipa/common"
	"github.com/crate-crypto/go-ipa/ipa"
)

func TestJavaRegressionOneEndian(t *testing.T) {
	hexStr := "f6e31f7a565a390b48fdd24569ac10d43562d19de37ea951c7f9f250a339d059"
	byteArray := hexStrToBytes(hexStr)
	_scalar, err := common.ReadScalar(bytes.NewReader(byteArray))

	if err == nil {
		t.Fatalf("expected an error because the scalar is too large")
	}
	_ = _scalar
}
func TestJavaRegressionOtherEndian(t *testing.T) {
	hexStr := "f6e31f7a565a390b48fdd24569ac10d43562d19de37ea951c7f9f250a339d059"
	byteArray := hexStrToBytes(hexStr)
	reverse(byteArray)
	_scalar, err := common.ReadScalar(bytes.NewReader(byteArray))
	if err == nil {
		t.Fatalf("expected an error because the scalar is too large, even though we changed the endian")
	}
	_ = _scalar
}

type AutoGenerated []struct {
	Frs      []string `json:"frs"`
	Expected string   `json:"expected"`
}

// genesis_lvl1_commitments.json was generated by serializing the scalars -1, -2,...,-256
// The scalars are encoded in big-endian format for now, so that the java code does not need
// much change.
func TestNewGenesisLvl1Commit(t *testing.T) {
	// Open the JSON file
	jsonFile, err := os.Open("../genesis_lvl1_commits.json")
	if err != nil {
		t.Fail()
		fmt.Println(err)
	}
	defer jsonFile.Close()

	// Read the opened jsonFile as a byte array.
	byteArray, _ := io.ReadAll(jsonFile)

	// We initialize our struct
	var testData AutoGenerated
	json.Unmarshal(byteArray, &testData)

	ipaConf, err := ipa.NewIPASettings()
	if err != nil {
		t.Fatalf("creating IPA settings: %s", err)
	}

	scalars := make([]fr.Element, common.VectorLength)

	serializedScalars := testData[0].Frs
	for i := 0; i < common.VectorLength; i++ {
		scalarBytes, err := hex.DecodeString(serializedScalars[i])
		if err != nil {
			t.Fatalf("decoding scalar bytes: %s", err)
		}
		reverse(scalarBytes) // Reverse bytes so we use LE
		scalars_i, err := common.ReadScalar(bytes.NewReader(scalarBytes))
		if err != nil {
			t.Fatalf("reading scalar: %s", err)
		}
		scalars[i] = *scalars_i
	}
	comm := ipaConf.Commit(scalars)
	commBytes := comm.Bytes()
	commHexStr := hex.EncodeToString(commBytes[:])
	if commHexStr != testData[0].Expected {
		t.Fatalf("expected %s, got %s", testData[0].Expected, commHexStr)
	}
}

func reverse(data []byte) {
	for i, j := 0, len(data)-1; i < j; i, j = i+1, j-1 {
		data[i], data[j] = data[j], data[i]
	}
}

func hexStrToBytes(numStr string) []byte {

	byteArray, err := hex.DecodeString(numStr)
	if err != nil {
		panic(err)
	}
	return byteArray
}
